
   """ Herencia """

Habiamos visto
/*******
2 pilares de la POO 
  -> Encapsulación: esta propiedad asegura que el estado interno de un objeto solo puede ser
     modificado por si mismo mediante metodos predefinidos. De esta manera el objeto expondra 
     hacia el exterior solo la información necesaria que desea comunicar. 
      Pensemos en un auto, este le comunica al resto que va realizar un giro, pero no expone 
     sus componentes internos, de esta manera solo provee la información necesaria para poder
     comunicarse con el resto. 
  
  -> Abstracción este principio hace referencia a que la clase debe representar las características
     de la entidad hacia el mundo exterior, pero ocultando la complejidad que lleva aparejada. Es 
     decir abstrae la complejidad, brindando una serie de atributos y metodos que podemos utilizar 
     sin preocuparnos por su implementación, este principio viene de la mano al principio de 
     Encapsulación.
*******/

Vamos a ver los otros dos pilares de la POO

  -> Herencia: esta es una de las caracteristicas mas potentes de este paradigma ya que permite 
     realizar relaciones jerarquicas entre clases, de forma que atributos y metodos seran heredados
     por las subclases, esto fomenta la reutilización de codigo.
     Asi podemos ver que la clase Animal tiene su estado y comportamiento, entonces podemos crear una 
     subclase Perro la cual heredará atributos y metodos de la clase Animal.

Veamos la clase Animal y como puede heredar la clase Gato


____________________________________________________________________________________________________

   Qué es una clase abstracta

      Las clases abstractas, como su nombre lo indica, son algo abstracto, 
      no representan algo específico y las podemos usar para crear otras clases. 
      No pueden ser instanciadas, por lo que no podemos crear nuevos objetos con ellas.
      Solamente se pueden usar para construir subclases. 
      Permitiendo así tener una única implementación de los métodos compartidos, evitando la duplicación de código.

      Resumiendo, las clases abstractas define una interfaz común para las subclases. 
      Proporciona atributos y métodos comunes para todas las subclases evitando así la necesidad de duplicar código. 
      Imponiendo además lo métodos que deber ser implementados para evitar inconsistencias entre las subclases.

   Creación de clases abstractas en Python

      Para poder crear clases abstractas en Python es necesario importar la clase ABC y el decorador abstractmethod 
      del modulo abc (Abstract Base Classes). Un módulo que se encuentra en la librería estándar del lenguaje, 
      por lo que no es necesario instalar. 
      Así para definir una clase privada solamente se tiene que crear una clase heredada de ABC con un método abstracto.

   from abc import ABC, abstractmethod

      class Animal(ABC):
         @abstractmethod
         def mover(self):
            pass

   
   Ahora si se intenta crear una instancia de la clase animal, 
   Python no lo permitirá indicando que no es posible. 
   Es importante notar que que si la clase no hereda de ABC o contiene por lo menos un método abstracto, 
   Python permitirá instancias las clases.


   Por otro lado, desde los métodos de las subclases podemos llamar a las implementaciones de la clase abstracta 
   con el comando super() seguido del nombre del método.

      class Animal(ABC):
         @abstractmethod
         def mover(self):
            pass
         
         @abstractmethod
         def comer(self):
            print('Animal come')

        
      class Gato(Animal):
         def mover(self):
            print('Mover gato')
            
            
         def comer(self):
            super().comer()
            print('Gato come')
            

      g = Gato()
      g.mover()
      g.comer()

Conclusiones
   En esta entrada se ha visto cómo se pueden usar el patrón de clase abstracta en Python. 
   Un patrón que es clave en programación orientada a objetos para evitar la repetición de código, 
   centralizando las funcionalidades comunes en una clase que sirve de plantilla para las clases hijas.


____________________________________________________________________________________________________

  """ Polimorfismo """

   La palabra Polimorfismo viene del griego "polys" que significa muchos
   y "morfo" que refiere a forma, su conjunto define la cualidad de 
   tener multiples formas.

   En POO, este concepto hace referencia a que varios objetos de clases distintas
   compartiendo una superclase en común, pueden definir un mismo metodo de 
   maneras distintas. 

     Ejercicio:
      Clases:
         Suma
         Reata
         Multiplicacion
         Division

      Clase Abstracta OperacionMatematica
        metodo abstracto:
            👉🏻 operar()
         
      Script operaciones_matematica.py

____________________________________________________________________________________________________
Vemaos la implementacion de la clase mi_fecha
   la clase MiFecha:
      - (==, <, <=, >=, >)
      - esta entre "una_fecha" y "otra_fecha"


Veamos la implementación de numero.py para el cual vamos a definir el mismo protocolo que realizamos en 
   La clase Numero: 
      - (==, <, <=, >=, >)
      - esta entre "un_numero" y "otro_numero"

Magnitudes lineales
   👉🏻 Cualquier magnitud que se pueda comparar linealmente puede utilizar la misma implementacion. 
   👉🏻 Solo necesita definir dos conceptos:
      -> igualdad
      -> ser menor a otra magnitud de mi clase

Pongamos en práctica.
Modelemos la clase MagnitudLineal 

   Protocolo:
      👉🏻 <= otra_magnitud   # metodo concreto
      👉🏻 > otra_magnitud    # metodo concreto
      👉🏻 >= otra_magnitud   # metodo concreto
      👉🏻 entre(una_magnitud, otra_magnitud)   # metodo concreto


      👉🏻 == otra_magnitud    # metodo abstracto
      👉🏻 <  otra_magnitud    # metodo abstracto

Por ultimo en MiFecha comentemos los metodos: "__le__" - "__ge__" - "__ge__" - "entreDosFechas"
Podemos ver que al correr los test nos acusan error porque no encuentra 
los metodos.

Ahora importemos la clase MagnitudLineal y hagamos que MiFecha herede de ella.
Al correr los test 🧪 estos pasan correctamente.
Excepto los del mensaje entreDosFechas puesto que no encuentra esa definición de mensaje.
podemos hacer dos cosas:
   -> Envolver el mensaje de la superclase 
         ejemplo: 
                def entreDosFechas(self, fecha_inicio, fecha_fin):
                     """ Devuelve un booleano si se encuentra entre las
                           dos fechas que recibe como parametro."""
                     return super().entre(fecha_inicio, fecha_fin)

   -> Cambiar los nombres en el setup de test 

Realicemos el mismo procedimiento con Numero. 
corran los test.

Si ahora modelaramos la clase Character sabiendo que cada caracter tiene un valor numerico ASCII
   Fuente: https://elcodigoascii.com.ar/

   En python contamos con dos funciones o metodos 
      -> ord('a')   # devuelve el valor ASCII
      >>> 97 

      -> chr(97)    # devuelve el caracter correspondiente
      >>> 'a'

Modelemos ahora Character haciendolo extender de MagnitudLineal y definamos los dos metodos
abstractos: 
   "__eq__"    y    "__lt__"

Realicen los test que validen su comportamiento.
 


